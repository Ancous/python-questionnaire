- ### Использовать замыкание
  
  Замыкание — это функция, которая сохраняет ссылку на переменные из своей внешней области видимости, даже когда эта
  область видимости больше не существует. Это позволяет функции работать с переменной, которая является статической,
  даже если она была определена вне функции.\
  <br>
  Вот пример использования замыкания для создания функции, которая использует статическую переменную:
  
  ```python
  def my_function():
      static_var = 0
      def inner_function():
          nonlocal static_var
          static_var += 1
          return static_var
      return inner_function
  
  # создаем объект функции, который использует статическую переменную
  f = my_function()
  
  # вызываем функцию несколько раз, чтобы увидеть изменение значения статической переменной
  print(f())  # выводит 1
  print(f())  # выводит 2
  print(f())  # выводит 3
  ```
  
  Этот код определяет функцию my_function, которая содержит внутри себя функцию inner_function, которая использует
  статическую переменную static_var. Каждый раз, когда inner_function вызывается через f(), значение static_var
  увеличивается на единицу и возвращается новое значение. Таким образом, каждый вызов f() возвращает увеличенное
  значение статической переменной.\
  <br>
  Важно, чтобы вы использовали ключевое слово nonlocal, чтобы объявить static_var как статическую переменную внутри
  inner_function, иначе Python будет считать ее локальной переменной и создает новую переменную каждый раз, когда
  inner_function вызывается.


- ### Использовать атрибут функции
  
  В Python функции — это объекты, и к ним можно добавлять атрибуты.\
  <br>
  Вот пример использования атрибута функции для создания функции, которая использует статическую переменную:
  
  ```Python
  def count_calls():
      if not hasattr(count_calls, "calls"):
          count_calls.calls = 0  # Инициализация статической переменной
      count_calls.calls += 1
      return count_calls.calls
  
  print(count_calls())  # выводит 1
  print(count_calls())  # выводит 2
  print(count_calls())  # выводит 3
  ```
  
  Первая проверка hasattr — создает атрибут counter при первом вызове.
  Значение сохраняется между вызовами, так как оно привязано к функции как к объекту.

<div align="right">

[Вернуться к вопросам](../Вопросы.md)

</div>
