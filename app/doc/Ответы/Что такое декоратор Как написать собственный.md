### Кратко

Декоратор в Python — это функция, которая позволяет обернуть другую функцию или метод для расширения или изменения их
поведения без изменения исходного кода.

Собственный декоратор пишется при помощи вложенных функций и оператора @.

### Развернуто

В Python декораторы — удобный инструмент для модификации поведения функций, методов или даже классов. Они реализуются
с помощью функций высшего порядка (функций, принимающих другие функции как аргументы и/или возвращающих их).

1. **Зачем нужны декораторы**
    
    - Добавление новой функциональности без изменения исходного кода функции/метода;
    - Повторное использование одинаковой логики (логирование, кэширование, аутентификация и т.д.);
    - Повышение читаемости и чистоты кода.

2. **Как работает декоратор**
    
    - Декоратор — это функция, которая принимает функцию и возвращает новую функцию (или объект с вызываемым
      интерфейсом):
      
      ```python
      def my_decorator(func):
          def wrapper():
              print("Что-то делаю до вызова функции")
              func()
              print("Что-то делаю после вызова функции")
          return wrapper

      @my_decorator
      def say_hello():
          print("Hello!")

      say_hello()

      # Что-то делаю до вызова функции
      # Hello!
      # Что-то делаю после вызова функции
      ```

3. **Поддержка аргументов**
    
    - Чтобы декоратор работал с функциями с любым количеством аргументов, используют *args и **kwargs:
      
       ```python
      def my_decorator(func):
          def wrapper(*args, **kwargs):
              print("Перед вызовом")
              result = func(*args, **kwargs)
              print("После вызова")
              return result
          return wrapper
      ```

4. **Сохранение метаданных**
    
    - Чтобы не терять имя и документацию функции при обёртывании, используют functools.wraps:
      
      ```python
      from functools import wraps
   
      def my_decorator(func):
          @wraps(func)
          def wrapper(*args, **kwargs):
              ...
              return func(*args, **kwargs)
          return wrapper
      ```

5. **Пример — собственный декоратор**
   
   ```python
   from functools import wraps
   
   def debug(func):
       @wraps(func)
       def wrapper(*args, **kwargs):
           print(f"Вызов {func.__name__} с args={args}, kwargs={kwargs}")
           result = func(*args, **kwargs)
           print(f"{func.__name__} вернула {result}")
           return result
       return wrapper

   @debug
   def add(a, b):
       return a + b

   add(2, 3)

   # Вызов add с args=(2, 3), kwargs={}
   # add вернула 5
   ```

6. **Декоратор с параметрами**
    
    - Иногда нужно, чтобы декоратор принимал параметры. В этом случае создаётся функция, возвращающая декоратор:
      
      ```python
      def repeat(n):
          def decorator(func):
              @wraps(func)
              def wrapper(*args, **kwargs):
                  for _ in range(n):
                      func(*args, **kwargs)
              return wrapper
          return decorator

      @repeat(3)
      def hello():
          print("Hi!")

      hello()

      # Hi!
      # Hi!
      # Hi!
      ```

7. **Где используются**
    
    - Логирование
    - Проверка прав
    - Кэширование результатов
    - Валидация входных данных
    - Измерение времени выполнения

Таким образом, декоратор — это мощный способ добавить или изменить поведение функций и методов в Python, соблюдая
принципы чистоты, повторного использования и расширяемости кода.

<div align="right">

[Вернуться к вопросам](../Вопросы.md)

</div>
