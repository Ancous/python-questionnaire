### Кратко

Функции можно расположить в следующем порядке эффективности: f2, f1, f3. Это связано с тем, как они обрабатывают
входной массив: f2 выполняет фильтрацию и сортировку в оптимальном порядке, тогда как f1 и f3 имеют более высокую
временную сложность из-за предварительной сортировки всего массива или из-за необходимости вычисления квадратов
всех элементов.

### Развернуто

Для анализа эффективности функций f1, f2 и f3 необходимо рассмотреть их временные сложности и порядок выполнения
операций.

1. **Функция f1(arr)**
    ```Python
    def f1(arr):
        l1 = sorted(arr)  # O(n log n)
        l2 = [i for i in l1 if i < .5]  # O(n)
        return [i * i for i in l2]  # O(m), где m - количество элементов в l2
    ```
    - Сначала происходит сортировка массива arr, что занимает O(n log n).
    - Затем производится фильтрация элементов, что занимает O(n).
    - Наконец, вычисляется квадрат каждого элемента, что занимает O(m), где m — количество элементов, прошедших
      фильтрацию.
    - Общая временная сложность: O(n log n + n + m), что в худшем случае сводится к O(n log n).

2. **Функция f2(arr)**
    ```Python
    def f2(arr):
        l1 = [i for i in arr if i < .5]  # O(n)
        l2 = sorted(l1)  # O(m log m), где m - количество элементов в l1
        return [i * i for i in l2]  # O(m)
    ```
    - В этой функции сначала выполняется фильтрация, что занимает O(n).
    - Затем происходит сортировка отфильтрованного массива, что занимает O(m log m).
    - Наконец, вычисляется квадрат каждого элемента, что занимает O(m).
    - Общая временная сложность: O(n + m log m + m), что в худшем случае сводится к O(n + m log m).

3. **Функция f3(arr)**
    ```Python
    def f3(arr):
        l1 = [i * i for i in arr]  # O(n)
        l2 = sorted(l1)  # O(n log n)
        return [i for i in l1 if i < (.5 * .5)]  # O(n)
    ```
    - В этой функции сначала вычисляется квадрат каждого элемента, что занимает O(n).
    - Затем происходит сортировка, что занимает O(n log n).
    - Наконец, выполняется фильтрация по условию, что занимает O(n).
    - Общая временная сложность: O(n + n log n + n), что сводится к O(n log n).

4. **Сравнение и выводы**
    - **f2** наиболее эффективна, так как она сначала фильтрует массив, а затем сортирует меньший по размеру массив.
      Это снижает количество операций, особенно если входной массив arr содержит много элементов больше 0.5.
    - **f1** имеет меньшее количество операций по фильтрации, но из-за предварительной сортировки всего массива она
      становится менее эффективной, когда размер массива велик.
    - **f3** также имеет высокую временную сложность из-за необходимости вычислять квадраты всех элементов перед
      сортировкой, что делает её наименее эффективной.

Таким образом, в порядке убывания эффективности функции располагаются как f2, f1, f3.

<div align="right">

[Вернуться к вопросам](../Вопросы.md)

</div>
