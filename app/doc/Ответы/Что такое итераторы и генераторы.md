## <u>Кратко</u>

Итераторы — объекты, поддерживающие методы `__iter__()` и `__next__()`, обеспечивающие последовательный доступ к
элементам коллекции. Генераторы — специальные функции, которые с помощью `yield` создают итераторы для ленивой генерации
значений.

## <u>Развернуто</u>

Итераторы и генераторы играют ключевую роль в работе с последовательностями в Python, позволяя обходить большие объёмы
данных эффективно и последовательно.

1. **Итераторы**
    - Объект, реализующий методы `__iter__()` (возвращает итератор) и `__next__()` (возвращает следующий элемент).
    - При достижении конца последовательности метод `__next__()` возбуждает исключение `StopIteration`.
    - Итераторы используются в циклах `for` и функциях, работающих с итерируемыми объектами.

2. **Генераторы**
    - Специальные функции с ключевым словом `yield`, возвращают генератор — итератор, который выдаёт значения по одному
      при каждом вызове `next()`.
    - Генераторы сохраняют своё состояние между вызовами, что позволяет эффективно работать с большими и потенциально
      бесконечными последовательностями.
    - Генераторы проще реализовать, чем классические итераторы с определением методов.

3. **Преимущества и недостатки**
    - **Итераторы:**
        - Позволяют проходить по различным коллекциям и структурам.
        - Требуют реализации специальных методов для создания.
    - **Генераторы:**
        - Очень удобны и лаконичны, экономят память.
        - Ленивы — значения вычисляются по требованию.
        - Не подходят, если нужен произвольный доступ к элементам или обратная итерация.

4. **Контекст использования**
    - Итераторы — основа работы с коллекциями в Python, включая списки, словари, множества.
    - Генераторы — при обработке больших данных, потоках, вычислениях, где важно не хранить всё сразу в памяти.

5. **Пример итератора и генератора:**
    ```python
    # Итератор классический
    class Countdown:
        def __init__(self, start):
            self.current = start
        def __iter__(self):
            return self
        def __next__(self):
            if self.current <= 0:
                raise StopIteration
            self.current -= 1
            return self.current + 1

    for num in Countdown(3):
        print(num)

    # Генератор
    def countdown(n):
        while n > 0:
            yield n
            n -= 1

    for num in countdown(3):
        print(num)
    ```

Таким образом, итераторы в Python — объекты для последовательного доступа к элементам, а генераторы — удобный способ их
создания с помощью функций с `yield`.

<div align="right">

[Вернуться к вопросам](../Вопросы.md)

</div>
