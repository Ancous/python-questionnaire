## <u>Кратко</u>

Да, генераторы в Python автоматически создают итераторы, позволяя лениво возвращать последовательность значений без
явного определения класса итератора.

## <u>Развернуто</u>

Генераторы — удобный способ создавать итераторы с минимальным кодом. Функция с `yield` возвращает объект-генератор,
который реализует протокол итератора, поддерживая методы `__iter__()` и `__next__()`.

1. **Как генераторы создают итераторы**
    - Использование ключевого слова `yield` превращает функцию в генератор.
    - Генератор сохраняет своё состояние на каждом `yield` и возвращает следующий элемент при вызове `next()`.
    - Генератор можно использовать в циклах или явно получать элементы через `next()`.

2. **Преимущества и недостатки**
    - **Преимущества:**
        - Простота и лаконичность реализации итераторов.
        - Ленивое вычисление элементов, экономия памяти.
    - **Недостатки:**
        - Генераторы нельзя "перематывать" назад без создания нового объекта.
        - Могут быть менее очевидны для начинающих.

3. **Контекст использования**
    - Последовательная обработка больших объёмов данных.
    - Реализация бесконечных последовательностей.
    - Упрощение создания пользовательских итераторов.

4. **Пример генератора — итератора:**
    ```python
    def countdown(n):
        while n > 0:
            yield n
            n -= 1

    for number in countdown(5):
        print(number)
    ```

Таким образом, генераторы автоматически создают итераторы, обеспечивая удобный и эффективный способ организации
последовательного доступа к данным.

<div align="right">

[Вернуться к вопросам](../Вопросы.md)

</div>
