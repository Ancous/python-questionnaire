## <u>Кратко</u>

Метод `__iter__` возвращает итератор объекта, а метод `__next__` возвращает следующий элемент последовательности при
итерации.

## <u>Развернуто</u>

В Python итерация организована вокруг двух протоколов — итератора и итерируемого объекта. Эти протоколы реализуются
через методы `__iter__` и `__next__`.

1. **Метод `__iter__`**
    - Определяет объект, который возвращает итератор.
    - Должен возвращать объект, реализующий метод `__next__`.
    - Обычно итерируемый объект сам возвращает себя, если он и есть итератор.

2. **Метод `__next__`**
    - Определён у итератора.
    - Возвращает следующий элемент последовательности при каждом вызове.
    - Если элементы закончились, возбуждает исключение `StopIteration`, сигнализируя об окончании итерации.

3. **Преимущества и недостатки**
    - **Преимущества:**
        - Позволяют реализовывать собственные итерационные объекты и управлять процессом итерации.
        - Обеспечивают совместимость с циклами `for` и другими итераторами Python.
    - **Недостатки:**
        - Требует понимания протокола итераторов для реализации.
        - Неправильная реализация может привести к бесконечным циклам или ошибкам.

4. **Контекст использования**
    - При создании собственных коллекций, генераторов, ленивых вычислений и потоковой обработки данных.

5. **Пример реализации итератора**
   ```python
   class CountDown:
       def __init__(self, start):
           self.current = start

       def __iter__(self):
           return self  # объект сам является итератором

       def __next__(self):
           if self.current <= 0:
               raise StopIteration
           else:
               self.current -= 1
               return self.current + 1

   for number in CountDown(3):
       print(number)
   # Вывод:
   # 3
   # 2
   # 1
   ```

Таким образом, `__iter__` возвращает итератор объекта, а `__next__` определяет способ получения следующего элемента при
итерации.

<div align="right">

[Вернуться к вопросам](../Вопросы.md)

</div>
