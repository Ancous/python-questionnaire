## <u>Кратко</u>

Многопроцессорное приложение использует несколько отдельных процессов с собственной памятью, а многопоточное — несколько
потоков внутри одного процесса, разделяющих общую память.

## <u>Развернуто</u>

Оба подхода служат для параллельного выполнения задач, но имеют разные архитектурные особенности и применения.

1. **Многопроцессорное приложение**
    - Запускает несколько процессов, каждый с отдельным адресным пространством и ресурсами.
    - Процессы изолированы друг от друга, что повышает стабильность и безопасность.
    - Межпроцессное взаимодействие сложнее и медленнее из-за необходимости обмена данными через каналы, очереди и другие
      механизмы.
    - В Python реализуется через модуль `multiprocessing`.

2. **Многопоточное приложение**
    - Работает с несколькими потоками внутри одного процесса, которые разделяют память и ресурсы.
    - Потоки могут быстро обмениваться данными через общую память, но возникает риск гонок и ошибок синхронизации.
    - В Python потоки управляются с помощью модуля `threading`.
    - Из-за GIL в стандартном интерпретаторе Python (CPython) многопоточность ограничена в вычислительной
      производительности.

3. **Преимущества и недостатки**
    - **Многопроцессорность:**
        - **Преимущества:** изоляция, нет проблем с GIL, может использовать несколько ядер CPU.
        - **Недостатки:** накладные расходы на создание и коммуникацию между процессами.
    - **Многопоточность:**
        - **Преимущества:** легковесность, быстрое взаимодействие между потоками.
        - **Недостатки:** проблемы с GIL, осложнённая синхронизация, возможны ошибки при совместном доступе к памяти.

4. **Контекст использования**
    - Многопроцессорность подходит для CPU-интенсивных задач и вычислений.
    - Многопоточное программирование — для I/O-операций, сетевых приложений, где важна отзывчивость.

5. **Пример:**
    ```python
    import threading
    import multiprocessing

    def worker():
        print("Работа в потоке или процессе")

    # Многопоток
    t = threading.Thread(target=worker)
    t.start()
    t.join()

    # Многопроцессор
    p = multiprocessing.Process(target=worker)
    p.start()
    p.join()
    ```

Таким образом, ключевое отличие — изоляция процессов и общая память потоков, что влияет на производительность, сложность
и сферу применения многопроцессорных и многопоточных приложений.

<div align="right">

[Вернуться к вопросам](../Вопросы.md)

</div>
