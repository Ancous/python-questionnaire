## <u>Кратко</u>

@classmethod, @staticmethod и @property — это специальные декораторы в Python, которые позволяют изменять поведение
методов внутри классов. Они обеспечивают разные способы работы с методами и атрибутами класса, улучшая инкапсуляцию
и читаемость кода.

## <u>Развернуто</u>

1. **@classmethod**
    - Декоратор @classmethod используется для определения метода, который принимает в качестве первого аргумента сам
      класс (обычно обозначаемый как cls), а не экземпляр класса. Это позволяет методам класса работать с классом, а не
      с конкретными объектами.
    ```Python
    class MyClass:
        class_variable = 0

        @classmethod
        def increment_class_variable(cls):
            cls.class_variable += 1
 
    MyClass.increment_class_variable()
    print(MyClass.class_variable)  # Выведет 1
    ```
    - Полезен для создания фабричных методов, которые могут создавать экземпляры класса, или для изменения состояния
      класса, а не его экземпляров.

2. **@staticmethod**
    - Декоратор @staticmethod используется для определения метода, который не зависит ни от экземпляра класса, ни от
      самого класса. Это означает, что метод может быть вызван без необходимости создания объекта класса.
    ```Python
    class MathUtils:
        @staticmethod
        def add(a, b):
            return a + b

    result = MathUtils.add(5, 3)
    print(result)  # Выведет 8
    ```
    - Полезен для создания утилитарных методов, которые не требуют доступа к данным класса или экземпляра, но логически
      связаны с классом.

3. **@property**
    - Декоратор @property позволяет определять методы, которые могут быть использованы как атрибуты. Это позволяет
      инкапсулировать доступ к атрибутам класса и управлять их значениями, не нарушая интерфейс.
    ```Python
    class Circle:
        def __init__(self, radius):
            self._radius = radius

        @property
        def area(self):
            return 3.14 * (self._radius ** 2)

    circle = Circle(5)
    print(circle.area)  # Выведет 78.5
    ```
    - Полезен для создания вычисляемых свойств, которые могут зависеть от других атрибутов класса, обеспечивая более
      чистый и понятный интерфейс.

4. **Сравнение и контекст использования**
    - **@classmethod**: Используется, когда метод должен работать с классом в целом, а не с его экземплярами. Это может
      быть полезно для создания методов, которые изменяют состояние класса или создают новые экземпляры.
    - **@staticmethod**: Используется для методов, которые не требуют доступа к состоянию класса или экземпляра, но
      логически связаны с классом. Это помогает организовать код и сделать его более читаемым.
    - **@property**: Используется для создания свойств, которые могут быть вычислены в зависимости от состояния объекта,
      позволяя скрыть внутренние детали реализации и предоставляя более чистый интерфейс для пользователя.
    ```Python
    class Employee:
        raise_amount = 1.05

        def __init__(self, name, salary):
            self.name = name
            self.salary = salary

        @classmethod
        def set_raise_amount(cls, amount):
            cls.raise_amount = amount

        @staticmethod
        def is_workday(day):
            return day.weekday() < 5

        @property
        def annual_salary(self):
            return self.salary * 12

    # Установка нового значения raise_amount
    Employee.set_raise_amount(1.10)

    # Проверка, является ли день рабочим
    import datetime
    print(Employee.is_workday(datetime.date(2023, 10, 2)))  # Выведет True

    # Получение ежегодной зарплаты
    emp = Employee("John", 3000)
    print(emp.annual_salary)  # Выведет 36000
    ```
   
   Этот пример демонстрирует, как можно использовать @classmethod, @staticmethod и @property для создания более
   структурированного и понятного кода.

<div align="right">

[Вернуться к вопросам](../Вопросы.md)

</div>
